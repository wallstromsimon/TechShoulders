---
import BaseLayout from '../../layouts/BaseLayout.astro';
import NodeHeader from '../../components/NodeHeader.astro';
import NodeAttribution from '../../components/NodeAttribution.astro';
import NodeLinks from '../../components/NodeLinks.astro';
import NodeCard from '../../components/NodeCard.astro';
import MiniGraph from '../../components/MiniGraph.tsx';
import { getAllNodeIds, findNodeById, loadAll, getOutgoingEdges, getIncomingEdges, buildNodeNeighborhoodData, type PersonEntry, type WorkEntry, type InstitutionEntry, type Edge } from '../../lib/data';

export async function getStaticPaths() {
  const ids = await getAllNodeIds();
  return ids.map(id => ({ params: { id } }));
}

const { id } = Astro.params;
const result = await findNodeById(id);

if (!result) {
  return Astro.redirect('/404');
}

const { kind, entry } = result;
const { Content } = await entry.render();

// Load all data for related items lookup
const allData = await loadAll();

// Build meta string based on kind
let meta = '';
let domains: string[] = [];

if (kind === 'people') {
  const person = entry as PersonEntry;
  meta = person.data.era;
  domains = person.data.domains || [];
} else if (kind === 'works') {
  const work = entry as WorkEntry;
  meta = `${work.data.kind} · ${work.data.year}`;
  domains = work.data.domains || [];
} else if (kind === 'institutions') {
  const inst = entry as InstitutionEntry;
  meta = inst.data.kind;
  if (inst.data.location) {
    meta += ` · ${inst.data.location}`;
  }
}

// Load edges for relationship-based lookups
const outgoingEdges = await getOutgoingEdges(id);
const incomingEdges = await getIncomingEdges(id);

// Get signature works for person pages (from influence edges)
let signatureWorks: { entry: WorkEntry; label: string }[] = [];
if (kind === 'people') {
  const influenceEdges = outgoingEdges.filter(e => e.kind === 'influence');
  for (const edge of influenceEdges) {
    const work = allData.works.find(w => w.data.id === edge.target);
    if (work) {
      signatureWorks.push({ entry: work, label: edge.label || 'contributed to' });
    }
  }
}

// Get related institutions for person pages (from affiliation edges)
let relatedInstitutions: { entry: InstitutionEntry; label: string }[] = [];
if (kind === 'people') {
  const affiliationEdges = outgoingEdges.filter(e => e.kind === 'affiliation');
  for (const edge of affiliationEdges) {
    const institution = allData.institutions.find(i => i.data.id === edge.target);
    if (institution) {
      relatedInstitutions.push({ entry: institution, label: edge.label || 'affiliated with' });
    }
  }
}

// For works, find related people (from incoming influence edges)
let relatedPeople: { entry: PersonEntry; label: string }[] = [];
if (kind === 'works') {
  for (const edge of incomingEdges) {
    if (edge.kind === 'influence') {
      const person = allData.people.find(p => p.data.id === edge.source);
      if (person) {
        relatedPeople.push({ entry: person, label: edge.label || 'contributed to' });
      }
    }
  }
}

// For institutions, find related people (from incoming affiliation edges)
let institutionPeople: { entry: PersonEntry; label: string }[] = [];
if (kind === 'institutions') {
  for (const edge of incomingEdges) {
    if (edge.kind === 'affiliation') {
      const person = allData.people.find(p => p.data.id === edge.source);
      if (person) {
        institutionPeople.push({ entry: person, label: edge.label || 'affiliated' });
      }
    }
  }
}

// Build Connections data for all node types
// "Influenced by" - people/works that influenced this node (incoming influence edges)
let influencedBy: { entry: PersonEntry | WorkEntry; label: string; kind: 'people' | 'works' }[] = [];
for (const edge of incomingEdges) {
  if (edge.kind === 'influence') {
    const person = allData.people.find(p => p.data.id === edge.source);
    if (person) {
      influencedBy.push({ entry: person, label: edge.label || 'influenced', kind: 'people' });
      continue;
    }
    const work = allData.works.find(w => w.data.id === edge.source);
    if (work) {
      influencedBy.push({ entry: work, label: edge.label || 'influenced', kind: 'works' });
    }
  }
}

// "Influenced" - people/works this node influenced (outgoing influence edges)
let influenced: { entry: PersonEntry | WorkEntry; label: string; kind: 'people' | 'works' }[] = [];
for (const edge of outgoingEdges) {
  if (edge.kind === 'influence') {
    const person = allData.people.find(p => p.data.id === edge.target);
    if (person) {
      influenced.push({ entry: person, label: edge.label || 'influenced', kind: 'people' });
      continue;
    }
    const work = allData.works.find(w => w.data.id === edge.target);
    if (work) {
      influenced.push({ entry: work, label: edge.label || 'contributed to', kind: 'works' });
    }
  }
}

// "Affiliations" - institutions connected to this node
let affiliations: { entry: InstitutionEntry; label: string }[] = [];
for (const edge of [...outgoingEdges, ...incomingEdges]) {
  if (edge.kind === 'affiliation') {
    // For outgoing: target is institution, For incoming: source is institution
    const instId = edge.source === id ? edge.target : edge.source;
    const institution = allData.institutions.find(i => i.data.id === instId);
    if (institution && !affiliations.some(a => a.entry.data.id === instId)) {
      affiliations.push({ entry: institution, label: edge.label || 'affiliated with' });
    }
  }
}

// Build neighborhood graph data for mini graph
const neighborhoodData = await buildNodeNeighborhoodData(id);
const graphNodes = neighborhoodData.nodes.map(n => ({
  id: n.id,
  name: n.name,
  kind: n.kind,
}));
const graphEdges = neighborhoodData.edges.map(e => ({
  source: e.source,
  target: e.target,
  kind: e.kind,
  label: e.label,
}));

// Check if there are any connections to show
// Show Connections section if there are list items OR if there's a neighborhood graph with more than just the current node
const hasConnections = influencedBy.length > 0 || influenced.length > 0 || affiliations.length > 0 || graphNodes.length > 1;

// Build SEO description
let description = '';
if (kind === 'people') {
  const person = entry as PersonEntry;
  description = person.data.title
    ? `${person.data.title}. ${person.data.era}.`
    : `Tech pioneer active ${person.data.era}.`;
  if (domains.length > 0) {
    description += ` Domains: ${domains.join(', ')}.`;
  }
} else if (kind === 'works') {
  const work = entry as WorkEntry;
  description = `${work.data.name} (${work.data.year}) - ${work.data.kind}.`;
  if (domains.length > 0) {
    description += ` Categories: ${domains.join(', ')}.`;
  }
} else if (kind === 'institutions') {
  const inst = entry as InstitutionEntry;
  description = `${inst.data.name} - ${inst.data.kind}`;
  if (inst.data.location) {
    description += ` located in ${inst.data.location}`;
  }
  description += '.';
}

// Get OG image
const ogImage = entry.data.image?.file.src;

// Determine OG type
const ogType = kind === 'people' ? 'profile' : 'article';
---

<BaseLayout
  title={entry.data.name}
  description={description}
  image={ogImage}
  type={ogType}
>
  <NodeHeader
    name={entry.data.name}
    kind={kind}
    meta={meta}
    image={entry.data.image}
  />

  {domains.length > 0 && (
    <div class="domains">
      {domains.map(domain => (
        <a href={`/browse?domain=${encodeURIComponent(domain)}`} class="domain-link">
          {domain}
        </a>
      ))}
    </div>
  )}

  <article class="content">
    <Content />
  </article>

  {kind === 'people' && signatureWorks.length > 0 && (
    <section class="related-section">
      <h2>Signature Works</h2>
      <div class="related-grid">
        {signatureWorks.map(({ entry: work, label }) => (
          <NodeCard entry={work} kind="works" variant="compact" relationshipLabel={label} />
        ))}
      </div>
    </section>
  )}

  {kind === 'people' && relatedInstitutions.length > 0 && (
    <section class="related-section">
      <h2>Related Institutions</h2>
      <div class="related-grid">
        {relatedInstitutions.map(({ entry: inst, label }) => (
          <NodeCard entry={inst} kind="institutions" variant="compact" relationshipLabel={label} />
        ))}
      </div>
    </section>
  )}

  {kind === 'works' && relatedPeople.length > 0 && (
    <section class="related-section">
      <h2>Key Contributors</h2>
      <div class="related-grid">
        {relatedPeople.map(({ entry: person, label }) => (
          <NodeCard entry={person} kind="people" variant="compact" relationshipLabel={label} />
        ))}
      </div>
    </section>
  )}

  {kind === 'institutions' && institutionPeople.length > 0 && (
    <section class="related-section">
      <h2>Notable People</h2>
      <div class="related-grid">
        {institutionPeople.map(({ entry: person, label }) => (
          <NodeCard entry={person} kind="people" variant="compact" relationshipLabel={label} />
        ))}
      </div>
    </section>
  )}

  {/* Connections Section - shows network relationships with mini graph */}
  {hasConnections && (
    <section class="connections-section">
      <h2>Connections</h2>

      <div class={`connections-layout ${(influencedBy.length === 0 && influenced.length === 0 && affiliations.length === 0) ? 'graph-only' : ''}`}>
        {/* Lists Column - only show if there are any list items */}
        {(influencedBy.length > 0 || influenced.length > 0 || affiliations.length > 0) && (
          <div class="connections-lists">
            {influencedBy.length > 0 && (
              <div class="connection-group">
                <h3>Influenced by</h3>
                <ul class="connection-list">
                  {influencedBy.map(({ entry: item, label, kind: itemKind }) => (
                    <li>
                      <a href={`/node/${item.data.id}`} class={`connection-link ${itemKind}`}>
                        {item.data.name}
                      </a>
                      <span class="connection-label">{label}</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {influenced.length > 0 && (
              <div class="connection-group">
                <h3>Influenced</h3>
                <ul class="connection-list">
                  {influenced.map(({ entry: item, label, kind: itemKind }) => (
                    <li>
                      <a href={`/node/${item.data.id}`} class={`connection-link ${itemKind}`}>
                        {item.data.name}
                      </a>
                      <span class="connection-label">{label}</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {affiliations.length > 0 && (
              <div class="connection-group">
                <h3>Affiliations</h3>
                <ul class="connection-list">
                  {affiliations.map(({ entry: inst, label }) => (
                    <li>
                      <a href={`/node/${inst.data.id}`} class="connection-link institutions">
                        {inst.data.name}
                      </a>
                      <span class="connection-label">{label}</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}

        {/* Mini Graph Column */}
        {graphNodes.length > 1 && (
          <div class="connections-graph">
            <MiniGraph
              client:load
              nodes={graphNodes}
              edges={graphEdges}
              focusNodeId={id}
            />
            <a href={`/graph`} class="view-full-graph">
              View full graph →
            </a>
          </div>
        )}
      </div>
    </section>
  )}

  {kind === 'people' && (entry as PersonEntry).data.whyYouCare && (
    <section class="why-care">
      <h2>Why You Should Care</h2>
      <ul class="reasons">
        {(entry as PersonEntry).data.whyYouCare!.map(reason => (
          <li>{reason}</li>
        ))}
      </ul>
    </section>
  )}

  <NodeLinks links={entry.data.links} />

  {entry.data.image && <NodeAttribution image={entry.data.image} />}
</BaseLayout>

<style>
  .domains {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: -1rem;
    margin-bottom: 1.5rem;
  }

  .domain-link {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 20px;
    font-size: 0.8rem;
    color: var(--color-muted);
    text-decoration: none;
    transition: all 0.15s ease;
  }

  .domain-link:hover {
    background: var(--color-link);
    color: white;
    border-color: var(--color-link);
    text-decoration: none;
  }

  .content {
    margin-top: 1.5rem;
  }

  .content :global(p) {
    margin-bottom: 1rem;
  }

  .content :global(h2) {
    margin-top: 2rem;
    margin-bottom: 0.75rem;
    font-size: 1.25rem;
  }

  .content :global(ul),
  .content :global(ol) {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
  }

  .content :global(li) {
    margin-bottom: 0.5rem;
  }

  .related-section {
    margin-top: 2.5rem;
    padding-top: 2rem;
    border-top: 1px solid var(--color-border);
  }

  .related-section h2 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--color-text);
  }

  .related-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 1rem;
  }

  .why-care {
    margin-top: 2.5rem;
    padding-top: 2rem;
    border-top: 1px solid var(--color-border);
  }

  .why-care h2 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
  }

  .reasons {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .reasons li {
    position: relative;
    padding-left: 1.5rem;
    margin-bottom: 0.75rem;
    line-height: 1.5;
  }

  .reasons li::before {
    content: "→";
    position: absolute;
    left: 0;
    color: var(--color-link);
    font-weight: bold;
  }

  /* Connections Section Styles */
  .connections-section {
    margin-top: 2.5rem;
    padding-top: 2rem;
    border-top: 1px solid var(--color-border);
  }

  .connections-section h2 {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1.25rem;
    color: var(--color-text);
  }

  .connections-layout {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    align-items: start;
  }

  .connections-layout.graph-only {
    grid-template-columns: 1fr;
    max-width: 500px;
  }

  .connections-lists {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  .connection-group h3 {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--color-muted);
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .connection-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .connection-list li {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    padding: 0.35rem 0;
    border-bottom: 1px solid var(--color-border);
  }

  .connection-list li:last-child {
    border-bottom: none;
  }

  .connection-link {
    font-weight: 500;
    text-decoration: none;
    transition: color 0.15s ease;
  }

  .connection-link:hover {
    text-decoration: underline;
  }

  .connection-link.people {
    color: #e74c3c;
  }

  .connection-link.works {
    color: #3498db;
  }

  .connection-link.institutions {
    color: #27ae60;
  }

  .connection-label {
    font-size: 0.8rem;
    color: var(--color-muted);
    font-style: italic;
  }

  .connections-graph {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .view-full-graph {
    font-size: 0.85rem;
    color: var(--color-link);
    text-decoration: none;
    text-align: right;
  }

  .view-full-graph:hover {
    text-decoration: underline;
  }

  @media (max-width: 800px) {
    .connections-layout {
      grid-template-columns: 1fr;
    }

    .connections-graph {
      order: -1;
    }
  }

  @media (max-width: 600px) {
    .related-grid {
      grid-template-columns: 1fr;
    }
  }
</style>
